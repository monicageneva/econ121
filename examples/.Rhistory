model1 <- lm_robust(assets ~ age + rural + ageXrural,data = nfhs,clusters = clustnum,weights = weight,se_type = "stata")
model1
# same t-statistic! assets rise less steeply with age in rural areas.
# we could also do this more elegantly using R's functionality around
# interaction terms, substituting "age * rural" for "age + rural + ageXrural".
# but it is easier to work with the coefficients afterwards if we do it the
# more cumbersome way.
# if we wanted to obtain the slope for rural areas from
# the interacted model, we would take a linear combination
# of the coefficient on age plus coefficient on the ruralXage
# interaction term. we use the glht function from the multcomp
# package to do this.
library(multcomp)
summary(glht(model1, linfct = "age + ageXrural = 0")))
summary(glht(model1, linfct = c("age + ageXrural = 0")))
summary(glht(model1, linfct = c("age + ageXrural")))
summary(glht(model1, linfct = c("age + ageXrural = 0")))
deltaMethod(model2,"age / (age + ageXrural)",rhs=1)
summary(deltaMethod(model2,"age / (age + ageXrural)",rhs=1))
boot1 <- Boot(model1,f=function(obj) coef(obj)[1]/(coef(obj)[1]+coef(obj)[3]),R=99)
boot1
model1
library(rms)
install.packages("rms")
library(rms)
model <- ols(assets ~ age + rural + ageXrural,data = nfhs, weights = weight, x=TRUE, y=TRUE)
model
bootcov(model,cluster=nfhs$clustnum,B=99)
bootcov(model,B=99)
model
model1
bootcov(model1a,cluster=nfhs$clustnum,B=99)
model1a <- ols(assets ~ age + rural + ageXrural,data = nfhs, weights = weight, x=TRUE, y=TRUE)
bootcov(model1a,cluster=nfhs$clustnum,B=99)
bootcov(model1a,cluster=nfhs$clustnum,B=999)
model1a <- ols(assets ~ age + rural + ageXrural,data = nfhs, x=TRUE, y=TRUE)
bootcov(model1a,cluster=nfhs$clustnum,B=99)
lm_robust(assets ~ age*rural,data = nfhs,clusters = clustnum,se_type = "stata")
library(haven)
nfhs_raw <- read_dta("https://github.com/tvogl/econ121/raw/main/data/nfhs4.dta")
# subset data to include only 20-80 year olds
nfhs <- nfhs_raw[which(nfhs_raw$age >= 20
& nfhs_raw$age <= 80),]
# we left off with estimates of a single slope,
# as a summary of a population pattern. recall
# that we used sampling weights, to ensure that
# the estimates are representative of the
# estimate we would obtain for the full population.
library(estimatr)
lm_robust(assets ~ age,data = nfhs,clusters = clustnum,weights=weight,se_type = "stata")
# heterogeneity between urban and rural areas
library(dplyr)
bygroup = nfhs %>% group_by(rural) %>% do(regs = lm_robust(assets ~ age,data = .,clusters = clustnum,weights = weight,se_type = "stata"))
bygroup$regs
# the urban/rural subsamples are independent, so we can compute
# a t-statistic for the difference in slopes "by hand"
(.006709-.0100517)/sqrt(.0001704^2+.000329^2)
# alternatively, we can use an interaction term.
#first generate the interaction term
nfhs$ageXrural <- nfhs$age * nfhs$rural
# now run the model and save the results as model1 for later
model1 <- lm_robust(assets ~ age + rural + ageXrural,data = nfhs,clusters = clustnum,weights = weight,se_type = "stata")
model1
# same t-statistic! assets rise less steeply with age in rural areas.
# we could also do this more elegantly using R's functionality for
# interaction terms, substituting "age * rural" for "age + rural + ageXrural".
# but it is easier to work with the coefficients afterwards if we do it the
# more cumbersome way.
# if we wanted to obtain the slope for rural areas from
# the interacted model, we would take a linear combination
# of the coefficient on age plus coefficient on the ruralXage
# interaction term. we use the glht function from the multcomp
# package to do this.
library(multcomp)
summary(glht(model1, linfct = c("age + ageXrural = 0")))
# same as we got when we estimated a separate regression for
# rural areas!
# note: in this sample, we could not compute the t-statistic
# ourselves if we were interested in male/female differences in
# slopes. the primary sampling units are clusters, so the male
# and female subsamples are not independent. our only option
# here is to use an interaction term. here we will take advantage
# of R's elegant functionality for interaction terms:
lm_robust(assets ~ age*male,data = nfhs,clusters = clustnum,weights = weight,se_type = "stata")
# no significant difference in slopes between men and women!
# now let's suppose we are interested in the ratio of the urban
# slope to the rural slope. we have two options.
# option 1: delta method (using deltaMethod in the car package).
# we use the interacted model we named model1.
library(car)
deltaMethod(model1,"age / (age + ageXrural)",rhs=1)
ratio.fn <- function(x) coef(x)[2]/(coef(x)[2] + coef(x)[4])
library(car)
boot.ratio <- Boot(model1a, f= ratio.fn, method = c("case"),labels = "ratio", R = 99)
boot.ratio <- Boot(model1, f= ratio.fn, method = c("case"),labels = "ratio", R = 99)
boot.ratio
Boot(model1, f= ratio.fn, method = c("case"),labels = "ratio", R = 99)
Boot(model1,f = ratio,method = c("case"),R = 99)
ratio <- function(x) coef(x)[2]/(coef(x)[2] + coef(x)[4])
Boot(model1,f = ratio,method = c("case"),R = 99)
length(nfhs&clusters)
length(nfhs$clustnum)
index <- sample(1:length(nfhs$clustnum), length(nfhs$clustnum), replace=TRUE)
index <- sample(n = 1:length(nfhs$clustnum),size = length(nfhs$clustnum),replace=TRUE)
length(nfhs$clustnum)
index <- sample(1:length(nfhs$clustnum), length(nfhs$clustnum), replace=TRUE)
aa <- nfhs$clustnum[index]
bb <- table(aa)
lm(assets ~ age*male,data = nfhs)
ratio
m <- lm(assets ~ age*male,data = nfhs)
ratio(m)
m <- lm(assets ~ age*rural,data = nfhs)
ratio(m)
bb <- table(nfhs$clustnum[index])
ratio(lm(assets ~ age*rural,data = nfhs))
library(haven)
nfhs_raw <- read_dta("https://github.com/tvogl/econ121/raw/main/data/nfhs4.dta")
cps18 <- read_dta("https://github.com/tvogl/econ121/raw/main/data/cps_18.dta")
summary(cps18)
table(cps18$race)
table(cps18$sex)
cps18$white <- ifelse(cps18$race == 1)
cps18$white <- ifelse(cps18$race == 1, 1, 0)
table(cps18$white)
cps18$white <- ifelse(cps18$race == '1', 1, 0)
cps18$white <- ifelse(cps18$race == 100, 1, 0)
table(cps18$white)
table(cps18$sex) #1 is male, 2 is female
cps18$white <- ifelse(cps18$race == 100, 1, 0)
cps18$black <- ifelse(cps18$race == 200, 1, 0)
cps18$male <- ifelse(cps18$sex == 1, 1, 0)
cps18$female <- ifelse(cps18$sex == 2, 1, 0)
cps18$lninc <- log(incwage)
cps18$lninc <- log(cps18incwage)
summary(cps18)
table(cps18$uhrsworkt) #100 is white, 200 is black
prop.table(cps18$uhrsworkt)
table_hrs <- table(cps18$uhrsworkt) #100 is white, 200 is black
prop.table(table_hrs) #report table with proportions instead of freq
prop.table(table_hrs)*100 #report table with proportions instead of freq
ps18_raw <- read_dta("https://github.com/tvogl/econ121/raw/main/data/cps_18.dta")
summary(cps18_raw)
# tables of race and sex - note: Stata labels have been removed
table(cps18_raw$race) #100 is white, 200 is black
table(cps18_raw$sex) #1 is male, 2 is female
# from the summary() results above, we know incwage has many 0s.
# over 25% of sample has 0s! restrict to workers who work 40+ hrs/wk.
table(cps18$uhrsworkt) #997 and 999 are top codes
cps18 <- cpw_raw[which(cps_raw$uhrsworkt >= 40 & cps_raw$uhrsworkt <= 170),]
rm(list=ls())
cps18 <- cpw_raw[which(cps_raw$uhrsworkt >= 40 & cps_raw$uhrsworkt <= 170),]
cps18 <- cpw_raw[which(cps_raw$uhrsworkt >= 40 & cps_raw$uhrsworkt <= 170),]
# this do-file studies the relationship or gender, race, and age
# with income in the united states, using the current population
# survey. it relies on nonparametric estimators.
# I will focus only on Black-white differences. If you are
# in other racial/ethnic groups, I encourage you to modify
# the do file in your spare time.
# input Stata file
library(haven)
cps18_raw <- read_dta("https://github.com/tvogl/econ121/raw/main/data/cps_18.dta")
summary(cps18_raw)
# tables of race and sex - note: Stata labels have been removed
table(cps18_raw$race) #100 is white, 200 is black
table(cps18_raw$sex) #1 is male, 2 is female
# from the summary() results above, we know incwage has many 0s.
# over 25% of sample has 0s! restrict to workers who work 40+ hrs/wk.
table(cps18$uhrsworkt) #997 and 999 are top codes
cps18 <- cpw_raw[which(cps_raw$uhrsworkt >= 40 & cps_raw$uhrsworkt <= 170),]
# cps18 is our analysis dataset, excluding people who work < 40 hours and
# people who are missing hours data
# generate white, black, male, female, log income (not hourly)
cps18$white <- ifelse(cps18$race == 100, 1, 0)
cps18$black <- ifelse(cps18$race == 200, 1, 0)
cps18$male <- ifelse(cps18$sex == 1, 1, 0)
cps18$female <- ifelse(cps18$sex == 2, 1, 0)
cps18$lninc <- log(cps18incwage)
cps18 <- cps_raw[which(cps_raw$uhrsworkt >= 40 & cps_raw$uhrsworkt <= 170),]
cps18 <- cps18_raw[which(cps18_raw$uhrsworkt >= 40 & cps18_raw$uhrsworkt <= 170),]
cps18$white <- ifelse(cps18$race == 100, 1, 0)
cps18$black <- ifelse(cps18$race == 200, 1, 0)
cps18$male <- ifelse(cps18$sex == 1, 1, 0)
cps18$female <- ifelse(cps18$sex == 2, 1, 0)
cps18$lninc <- log(cps18$incwage)
sd(cps18$lninc,na.rm=TRUE)
cps18_raw <- read_dta("https://github.com/tvogl/econ121/raw/main/data/cps_18.dta")
cps18 <- cps18_raw[which(cps18_raw$uhrsworkt >= 40 & cps18_raw$uhrsworkt <= 170),]
cps18$white <- ifelse(cps18$race == 100, 1, 0)
cps18$black <- ifelse(cps18$race == 200, 1, 0)
cps18$male <- ifelse(cps18$sex == 1, 1, 0)
cps18$female <- ifelse(cps18$sex == 2, 1, 0)
cps18$lninc <- log(cps18$incwage)
# what is the sd of lninc?
sd(cps18$lninc,na.rm=TRUE)
# this do-file studies the relationship or gender, race, and age
# with income in the united states, using the current population
# survey. it relies on nonparametric estimators.
# I will focus only on Black-white differences. If you are
# in other racial/ethnic groups, I encourage you to modify
# the do file in your spare time.
# input Stata file
library(haven)
cps18_raw <- read_dta("https://github.com/tvogl/econ121/raw/main/data/cps_18.dta")
summary(cps18_raw)
# tables of race and sex - note: Stata labels have been removed
table(cps18_raw$race) #100 is white, 200 is black
table(cps18_raw$sex) #1 is male, 2 is female
# from the summary() results above, we know incwage has many 0s.
# over 25% of sample has 0s! restrict to workers who work 40+ hrs/wk.
table(cps18$uhrsworkt) #997 and 999 are top codes
cps18 <- cps18_raw[which(cps18_raw$uhrsworkt >= 40 & cps18_raw$uhrsworkt <= 170),]
# cps18 is our analysis dataset, excluding people who work < 40 hours and
# people who are missing hours data
# generate white, black, male, female, log income (not hourly)
cps18$white <- ifelse(cps18$race == 100, 1, 0)
cps18$black <- ifelse(cps18$race == 200, 1, 0)
cps18$male <- ifelse(cps18$sex == 1, 1, 0)
cps18$female <- ifelse(cps18$sex == 2, 1, 0)
cps18$lninc <- log(cps18$incwage)
# what is the sd of lninc?
sd(cps18$lninc,na.rm=TRUE)
# kernel density estimates of log income by race and sex
# let's use .25 as the bandwidth, about a quarter of the sd of lninc.
# Libraries
library(tidyverse)
# library(hrbrthemes)
# library(dplyr)
# library(tidyr)
# library(viridis)
# The diamonds dataset is natively available with R.
# Without transparency (left)
p1 <- ggplot(data=cps18, aes(x=lninc, group=white, fill=white)) +
geom_density(adjust=1.5)
p1 <- ggplot(data=cps18, aes(x=lninc, group=white, fill=cut)) +
geom_density(adjust=1.5)
p1 <- ggplot(data=cps18, aes(x=lninc, group=cut, fill=cut)) +
geom_density(adjust=1.5)
p1
p1 <- ggplot(data=cps18, aes(x=lninc, group=white, fill=white)) +
geom_density(adjust=1.5)
p1
p1 <- ggplot(data=cps18, aes(x=lninc, group=white, fill=white)) +
geom_density(adjust=1.5, alpha=.4)
p1
p1 <- ggplot(data=cps18, aes(x=lninc)) +
geom_density(adjust=1.5, alpha=.4)
p1
p1 <- ggplot(data=cps18, aes(x=lninc)) +
geom_density(adjust=1.5)
p1
p1 <- ggplot(data=cps18, aes(x=lninc)) +
geom_density(bw=.25)
p1
cps18$racesex <- as.factor(ifelse(cps18$race == 200 & cps18$sex == 2, 'Black women',
ifelse(cps18$race == 100 & cps18$sex == 2, 'White women',
ifelse(cps18$race == 200 & cps18$sex == 1, 'Black men',
ifelse(cps18$race == 100 & cps18$sex == 1, 'White men')))))
cps18$racesex <- as.factor(ifelse(cps18$race == 200 & cps18$sex == 2, 'Black women',
ifelse(cps18$race == 100 & cps18$sex == 2, 'White women',
ifelse(cps18$race == 200 & cps18$sex == 1, 'Black men',
ifelse(cps18$race == 100 & cps18$sex == 1, 'White men', 'Other')))))
p1 <- ggplot(data=cps18, aes(x=lninc,group=racesex)) +
geom_density(bw=.25)
p1
cps18 <- cps18[which(cps18$race <=200),]
# generate white, black, male, female, log income (not hourly)
cps18$racesex <- as.factor(ifelse(cps18$race == 200 & cps18$sex == 2, 'Black women',
ifelse(cps18$race == 100 & cps18$sex == 2, 'White women',
ifelse(cps18$race == 200 & cps18$sex == 1, 'Black men',
ifelse(cps18$race == 100 & cps18$sex == 1, 'White men', 'Other')))))
p1 <- ggplot(data=cps18, aes(x=lninc,group=racesex)) +
geom_density(bw=.25)
p1
p1 <- ggplot(data=cps18, aes(x=lninc,group=racesex)) +
geom_density(bw=.25) +
theme(ipsum)
p1
library(viridis) $for colors
library(viridis) #for colors
p1 <- ggplot(data=cps18, aes(x=lninc,group=racesex)) +
geom_density(bw=.25) +
theme(ipsum)
p1
library(hrbrthemes) #for theme of graph
p1 <- ggplot(data=cps18, aes(x=lninc,group=racesex)) +
geom_density(bw=.25) +
theme(ipsum)
p1
p1 <- ggplot(data=cps18, aes(x=lninc,group=racesex)) +
geom_density(bw=.25) +
theme(ipsum)
p1
p1 <- ggplot(data=cps18, aes(x=lninc,group=racesex)) +
geom_density(bw=.25)
p1
p1 <- ggplot(data=cps18, aes(x=lninc,group=racesex,fill(racesex))) +
geom_density(bw=.25)
p1
p1 <- ggplot(data=cps18, aes(x=lninc,group=racesex,fill=racesex)) +
geom_density(bw=.25)
p1
p1 <- ggplot(data=cps18, aes(x=lninc,group=racesex,fill=racesex)) +
geom_density(bw=.25,alpha=.4) #alpha specifies the transparency of the colors
p1
ggplot(data=cps18, aes(x=lninc,group=racesex,fill=racesex)) +
geom_density(bw=.25,a
ggplot(data=cps18, aes(x=lninc,group=racesex,fill=racesex)) +
geom_density(bw=.25,alpha=.4) #alpha specifies the transparency of the colors
ggplot(data=cps18, aes(x=lninc,group=racesex,fill=racesex)) +
geom_density(bw=.25,alpha=.4) #alpha specifies the transparency of the colors
ggplot(data=cps18, aes(x=lninc,group=racesex,fill=racesex)) +
geom_density(bw=.1,alpha=.4) #alpha specifies the transparency of the colors
ggplot(data=cps18, aes(x=age, y= lninc)) +
geom_point() +
geom_smooth()
ggplot(data=cps18, aes(x=age, y= lninc)) +
geom_smooth()
ggplot(data=cps18, aes(x=age, y= lninc)) +
geom_smooth(se=FALSE)
ggplot(data=cps18, aes(x=age, y= lninc, group=racesex)) +
geom_smooth(se=FALSE)
ggplot(data=cps18, aes(x=age, y= lninc, group=racesex, fill=racesex)) +
geom_smooth(se=FALSE)
ggplot(data=cps18, aes(x=age, y= lninc, group=racesex, fill=racesex)) +
geom_smooth(method=loess,se=FALSE)
ggplot(data=cps18, aes(x=age, y= lninc, group=racesex, fill=racesex)) +
geom_smooth(method=stats::loess(lninc~age,data=cps18,span=1,degree=1),se=FALSE)
install.packages("KernSmooth")
library(KernSmooth)
model1 <- locpoly(x=age, y=lninc, bandwidth=1, degree=1)
model1 <- locpoly(x=cps18$age, y=cps18$lninc, bandwidth=1, degree=1)
model1 <- locpoly(x=cps18$age, y=cps18$lninc, bandwidth=1)
cps18 <- cps18[complete.cases(cps18$lninc), ]
model1 <- locpoly(x=cps18$age, y=cps18$lninc, bandwidth=1, degree=1)
cps18 <- na.omit(cps18)
cps18 <- cps18_raw[which(cps18_raw$uhrsworkt >= 40 & cps18_raw$uhrsworkt <= 170),]
cps18 <- cps18[which(cps18$race <=200),]
cps18 <- na.omit(cps18)
sd(nlsy79$lninc)
sd(cps18$lninc)
cps18new <- cps18[complete.cases(cps18$lninc), ]
cps18 <- cps18_raw[which(cps18_raw$uhrsworkt >= 40 & cps18_raw$uhrsworkt <= 170),]
# cps18 is our analysis dataset, excluding people who work < 40 hours and
# people who are missing hours data. let's also exclude non-black/white individuals
cps18 <- cps18[which(cps18$race <=200),]
# generate white, black, male, female, log income (not hourly)
cps18$racesex <- as.factor(ifelse(cps18$race == 200 & cps18$sex == 2, 'Black women',
ifelse(cps18$race == 100 & cps18$sex == 2, 'White women',
ifelse(cps18$race == 200 & cps18$sex == 1, 'Black men',
ifelse(cps18$race == 100 & cps18$sex == 1, 'White men', 'Other')))))
cps18$lninc <- log(cps18$incwage)
cps18_raw <- read_dta("https://github.com/tvogl/econ121/raw/main/data/cps_18.dta")
summary(cps18_raw)
# tables of race and sex - note: Stata labels have been removed
table(cps18_raw$race) #100 is white, 200 is black
table(cps18_raw$sex) #1 is male, 2 is female
# from the summary() results above, we know incwage has many 0s.
# over 25% of sample has 0s! restrict to workers who work 40+ hrs/wk.
table(cps18$uhrsworkt) #997 and 999 are top codes
cps18 <- cps18_raw[which(cps18_raw$uhrsworkt >= 40 & cps18_raw$uhrsworkt <= 170),]
# cps18 is our analysis dataset, excluding people who work < 40 hours and
# people who are missing hours data. let's also exclude non-black/white individuals
cps18 <- cps18[which(cps18$race <=200),]
# generate white, black, male, female, log income (not hourly)
cps18$racesex <- as.factor(ifelse(cps18$race == 200 & cps18$sex == 2, 'Black women',
ifelse(cps18$race == 100 & cps18$sex == 2, 'White women',
ifelse(cps18$race == 200 & cps18$sex == 1, 'Black men',
ifelse(cps18$race == 100 & cps18$sex == 1, 'White men', 'Other')))))
cps18$lninc <- log(cps18$incwage)
cps18new <- cps18[complete.cases(cps18$lninc), ]
is.na(cps18$lninc)
mean(cps18$lninc)
cps18_raw <- read_dta("https://github.com/tvogl/econ121/raw/main/data/cps_18.dta")
summary(cps18_raw)
# tables of race and sex - note: Stata labels have been removed
table(cps18_raw$race) #100 is white, 200 is black
table(cps18_raw$sex) #1 is male, 2 is female
# from the summary() results above, we know incwage has many 0s.
# over 25% of sample has 0s! restrict to workers who work 40+ hrs/wk.
table(cps18$uhrsworkt) #997 and 999 are top codes
cps18 <- cps18_raw[which(cps18_raw$uhrsworkt >= 40 & cps18_raw$uhrsworkt <= 170),]
# cps18 is our analysis dataset, excluding people who work < 40 hours and
# people who are missing hours data. let's also exclude non-black/white individuals
cps18 <- cps18[which(cps18$race <=200),]
cps18$racesex <- as.factor(ifelse(cps18$race == 200 & cps18$sex == 2, 'Black women',
ifelse(cps18$race == 100 & cps18$sex == 2, 'White women',
ifelse(cps18$race == 200 & cps18$sex == 1, 'Black men',
ifelse(cps18$race == 100 & cps18$sex == 1, 'White men', 'Other')))))
cps18 <- cps18[which(cps18$incwage > 0),]
cps18$lninc <- log(cps18$incwage)
sd(cps18$lninc)
model1 <- locpoly(x=cps18$age, y=cps18$lninc, bandwidth=1, degree=1)
plot(model1)
plot(model1,type(l))
plot(model1,type="l")
plot(model1,type="line")
plot(model1,type="l")
ggplot(data = m1, aes(x = x, y = y)) +
geom_line(color = "blue") +
theme_bw()
m1 <- data.frame(model1)
ggplot(data = m1, aes(x = x, y = y)) +
geom_line(color = "blue") +
theme_bw()
plot(model1,type="l")
ggplot(data = m1, aes(x = x, y = y)) +
geom_line(color = "blue") +
theme_bw()
ggplot(data = m1, aes(x = x, y = y)) +
geom_line(color = "blue")
ggplot(data = m1, aes(x = x, y = y)) +
geom_line()
library(haven)
nfhs_raw <- read_dta("https://github.com/tvogl/econ121/raw/main/data/nfhs4.dta")
# subset data to include only 20-80 year olds
nfhs <- nfhs_raw[which(nfhs_raw$age >= 20
& nfhs_raw$age <= 80),]
library(dplyr) #for collapsing by age
library(radiant.data) #for weighted sd function
nfhs_collapsed <- nfhs %>% group_by(age) %>%
summarize(mean=weighted.mean(assets,w=weight),
sd = weighted.sd(assets,w=weight),
n=n())
library(ggplot2) #for plots
library(ggpubr) #to combine plots
ggplot(nfhs_collapsed, aes(x=age, y=n)) + geom_point(shape=21)
ggplot(nfhs_collapsed, aes(x=age, y=n)) + geom_point()
plot1 <- ggplot(nfhs_collapsed, aes(x=age, y=mean, size=n)) +
geom_point(show.legend=FALSE)
plot2 <- ggplot(nfhs_collapsed, aes(x=age, y=sd), size=n) +
geom_point(show.legend=FALSE)
ggarrange(plot1, plot2, ncol = 1, nrow = 2)
# analysis of bacon consumption in the national health interview survey.
# open nhis dta and summarize.
library(haven)
nhis_raw <- read_dta("https://github.com/tvogl/econ121/raw/main/data/nhis2000.dta")
summary(nhis_raw)
# drop observations with bacon missing.
# generate a variable that equals one if any bacon consumption, zero otherwise.
nhis <- nhis_raw[!is.na(nhis_raw$bacon),]
table(nhis$bacon)
nhis$anybacon <- ifelse(nhis$bacon > 0, 1, 0)
# generate some covariates.
# gender.
table(nhis$sex)
nhis$male <- 2-nhis$sex
# marital status
table(nhis$marstat)
nhis$married <- ifelse(nhis$marstat < 20, 1, 0)
install.packages("glmx")
library(haven)
nhis_raw <- read_dta("https://github.com/tvogl/econ121/raw/main/data/nhis2000.dta")
table(nhis_raw$health)
nhis <- read_dta("https://github.com/tvogl/econ121/raw/main/data/nhis2000.dta")
summary(nhis)
table(nhis$age)
prop.table(nhis$age)
prop.table(table(nhis$age)
)
prop.table(table(nhis$health)) # prop.table converts frequencies into proportions
mean(nhis$sex)
table(nhis$sex)
prop.table(table(nhis$sex))
mean(nhis$sex)
weighted.mean(nhis$sex,w=sampweight) # 57% female
weighted.mean(nhis$sex,w = nhis$sampweight) # 57% female
poorhealth <- subset(nhis, fpoor==1, select=c(age, mort5))
notpoorhealth <- subset(nhis, fpoor==0, select=c(age, mort5))
library(KernSmooth)
poorreg <- data.frame(locpoly(x=poorhealth$age, y=poorhealth$mort5, bandwidth=1, degree=1))
notpoorreg <- data.frame(locpoly(x=notpoorhealth$age, y=notpoorhealth$mort5, bandwidth=1, degree=1))
ggplot() +
geom_line(data = poorreg, aes(x = x, y = y,color = "Fair/poor")) +
geom_line(data = notpoorreg, aes(x = x, y = y,color = "Good/Very Good/Excellent")) +
labs(x="age", y="mort5", color = "Legend") +
scale_color_manual(values = c("Fair/poor" = "black", "Good/Very Good/Excellent" = "grey"))
poorhealth <- subset(nhis, fpoor==1, select=c(age, mort5))
notpoorhealth <- subset(nhis, fpoor==0, select=c(age, mort5))
library(KernSmooth)
poorreg <- data.frame(locpoly(x=poorhealth$age, y=poorhealth$mort5, bandwidth=1, degree=1))
notpoorreg <- data.frame(locpoly(x=notpoorhealth$age, y=notpoorhealth$mort5, bandwidth=1, degree=1))
library(ggplot2)
ggplot() +
geom_line(data = poorreg, aes(x = x, y = y,color = "Fair/poor")) +
geom_line(data = notpoorreg, aes(x = x, y = y,color = "Good/Very Good/Excellent")) +
labs(x="age", y="mort5", color = "Legend") +
scale_color_manual(values = c("Fair/poor" = "black", "Good/Very Good/Excellent" = "grey"))
poorhealth <- subset(nhis, fpoor==1, select=c(age, mort5))
nhis$fpoor <- ifelse(nhis$health > 3, 1, 0)
poorhealth <- subset(nhis, fpoor==1, select=c(age, mort5))
notpoorhealth <- subset(nhis, fpoor==0, select=c(age, mort5))
library(KernSmooth)
poorreg <- data.frame(locpoly(x=poorhealth$age, y=poorhealth$mort5, bandwidth=1, degree=1))
notpoorreg <- data.frame(locpoly(x=notpoorhealth$age, y=notpoorhealth$mort5, bandwidth=1, degree=1))
library(ggplot2)
ggplot() +
geom_line(data = poorreg, aes(x = x, y = y,color = "Fair/poor")) +
geom_line(data = notpoorreg, aes(x = x, y = y,color = "Good/Very Good/Excellent")) +
labs(x="age", y="mort5", color = "Legend") +
scale_color_manual(values = c("Fair/poor" = "black", "Good/Very Good/Excellent" = "grey"))
poorhealth <- subset(nhis, fpoor==1 & !is.na(mort5), select=c(age, mort5))
notpoorhealth <- subset(nhis, fpoor==0 & !is.na(mort5), select=c(age, mort5))
library(KernSmooth)
poorreg <- data.frame(locpoly(x=poorhealth$age, y=poorhealth$mort5, bandwidth=1, degree=1))
notpoorreg <- data.frame(locpoly(x=notpoorhealth$age, y=notpoorhealth$mort5, bandwidth=1, degree=1))
library(ggplot2)
ggplot() +
geom_line(data = poorreg, aes(x = x, y = y,color = "Fair/poor")) +
geom_line(data = notpoorreg, aes(x = x, y = y,color = "Good/Very Good/Excellent")) +
labs(x="age", y="mort5", color = "Legend") +
scale_color_manual(values = c("Fair/poor" = "black", "Good/Very Good/Excellent" = "grey"))
